---
title: "Mutable"
weight: 3
draft: false
---

## Константные функции
В рассматриваемой структуре **Segment** функция **length** очевидно не должна изменять внутренние поля стрктуры, а только возврщать значение основываясь на текущих внутренних значениях. Это часто бывает полезно указать, что данный метод является своего рода "расширением" или предоставлением какой-либо информации основываясь только на текущем состоянии структуры. Такие метод можно пометить ключевым словом **const** сделав функцию константой:
```cpp
struct Segment {
    Point p1;
    Point p2;
    double length() const {
        double dx = p1.x – p2.x;
        double dy = p1.y – p2.y;
        return sqrt(dx * dx + dy * dy);
    }
};
```

{{% notice note %}}
* Константные функции не могут изменять поля объекта
* Внутри константных функций можно вызывать только константные методы
{{% /notice %}}

## Mutable
Что, если все-таки нам необъхоимо иметь доступ к изменению какого-либо поля внутри константных функций (например приращения счетчика вызовов данной функции)? B С++ и на это есть решение - в таких случаях поле структуры, которое будет разрешено изменять в константной функции нужно пометить как **mutable**:
```cpp
struct Segment {
    Point p1;
    Point p2;
    double length() const {
        counter++;
        double dx = p1.x – p2.x;
        double dy = p1.y – p2.y;
        return sqrt(dx * dx + dy * dy);
    }
private:
    mutable int counter;
};
```

{{% notice note %}}
В приведенном примере поле **counter** за модификтором **private** делая его недоступным для вызова извне. Таки образом **counter** является внутренним полем. (подробнее о модификаторах доступа будет описано позднее)
{{% /notice %}}