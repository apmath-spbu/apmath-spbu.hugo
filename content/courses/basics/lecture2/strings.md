---
title: "Строки"
weight: 4
draft: false
---

## C-style строки
В языке C строки представляли как массивы **char**-ов, которые заканчиваются специальным символом `\0` (на самом деле, это просто символ с номером 0). 

C++ сохраняет (в основном) совместимость с языком C, и поэтому поддерживает работу с C-style строками.

```cpp
char s[15] = "C-style string";
char s2[] = "C-style string"; // размер массива 15 char-ов
```
{{% notice warning %}}
Знать о строках C-style стоит, так как они используются не так уж и редко, но использовать их без веской на то причины не рекомендуется
{{% /notice %}}

## C++ строки

В языке C++ для удобной работы со строками есть класс **string**, для использования которого необходимо подключить заголовочный файл **string**.

Строки можно объявлять и одновременно присваивать им значения:

```cpp
#include <string>
string S1, S2 = "Hello";
```

Строка S1 будет пустой, строка S2 будет состоять из 5 символов.

К отдельным символам строки можно обращаться по индексу, как к элементам массива или C-строк. Например S[0] - это первый символ строки.

Для того, чтобы узнать длину строки можно использовать метод size() строки. Например, последний символ строки S это S[S.size() - 1].

### Ввод-вывод строк
Строка выводится точно так же, как и числовые значения:
```
cout << S;
```
Считаывание происходит аналогичным образом:
```
cin >> S;
```

В этом случае считывается строка из **непробельных** символов, пропуская пробелы и концы строк. Это удобно для того, чтобы разбивать текст на слова, или чтобы читать данные до конца файла при помощи `while (cin >> S)`.

Можно считывать строки до появления символа конца строки при помощи функции **getline**. Сам символ конца строки считывается из входного потока, но к строке не добавляется:
```
getline(cin S);
```

Для автоматического разбора строки на переменные соответствующих можно использовать класс **stringstream**:
```cpp
string str = "23,4,56";
stringstream ss(str);
char ch;
int a, b, c;
ss >> a >> ch >> b >> ch >> c; // a = 23, b = 4, c = 56
```

Для определения признака окончания потока можно использовать метод **eof()**:
```cpp
#include <iostream>
#include <sstream>
#include <string>
using namespace std;

int main() {
   stringstream ss("hello");
   char c;

   ss.get(c);
   while(!ss.eof()) {
      cout << "char: " << c << endl;
      ss.get(c);
   }
   return 0;
}
```

## Методы строк

У строк есть разные методы, многие из них можно использовать несколькими разными способами (с разным набором параметров). В данной секции важно отметить какие есть возможности у строки, но не пытаться все запомнить в деталях.

Рассмотрим эти методы подробней:

### size

Метод `size()` возращает длину длину строки. Возвращаемое значение является беззнаковым типом (как и во всех случаях, когда функция возращает значение, равное длине строке или индексу элемента - эти значения беззнаковые). Поэтому нужно аккуратно выполнять операцию вычитания из значения, которое возвращает `size()`. Например, ошибочным будет запись цикла, перебирающего все символы строки, кроме последнего, в виде `for (int i = 0; i < S.size() - 1; ++i)`.

Кроме того, у строк есть метод `length()`, который также возвращает длину строки.

### resize
`S.resize(n)` - Изменяет длину строки, новая длина строки становится равна n. При этом строка может как уменьшится, так и увеличиться. Если вызвать в виде `S.resize(n, c)`, где c - символ, то при увеличении длины строки добавляемые символы будут равны c.

### clear
`S.clear()` - очищает строчку, строка становится пустой.

### empty
`S.empty()` - возвращает **true**, если строка пуста, **false** - если непуста.

### push_back
`S.push_back(c)` - добавляет в конец строки символ c, вызывается с одним параметром типа **char**.

### append
Добавляет в конец строки несколько символов, другую строку или фрагмент другой строки. Имеет много способов вызова.

`S.append(n, c)` - добавляет в конец строки n одинаковых символов, равных с. n имеет целочисленный тип, c - **char**.

`S.append(T)` - добавляет в конец строки S содержимое строки T. T может быть объектом класса **string** или C-строкой.

`S.append(T, pos, count)` - добавляет в конец строки S символы строки T начиная с символа с индексом pos количеством count.

### erase
`S.erase(pos)` - удаляет из строки S  с символа с индексом pos и до конца строки.

`S.erase(pos, count)` - удаляет из строки S  с символа с индексом pos количеством count или до конца строки, если pos + count > S.size().

### insert
Вставляет в середину строки несколько символов, другую строку или фрагмент другой строки. Способы вызова аналогичны способам вызова метода append, только первым параметром является значение i - позиция, в которую вставляются символы. Первый вставленный символ будет иметь индекс i, а все символы, которые ранее имели индекс i и более сдвигаются вправо.

`S.insert(i, n, c)` - вставить n одинаковых символов, равных с. n имеет целочисленный тип, c - **char**.

`S.insert(i, T)` - вставить содержимое строки T. T может быть объектом класса string или C-строкой.

`S.insert(i, T, pos, count)` - вставить символы строки T начиная с символа с индексом pos количеством count.

### substr
`S.substr(pos)` - возвращает подстроку данной строки начиная с символа с индексом pos и до конца строки.

`S.substr(pos, count)` - возвращает подстроку данной строки начиная с символа с индексом pos количеством count или до конца строки, если pos + count > S.size().

### replace
Заменяет фрагмент строки на несколько равных символов, другую строку или фрагмент другой строки. Способы вызова аналогичны способам вызова метода append, только первыми двумя параметрами являются два числа: pos и count. Из данной строки удаляется count символов, начиная с символа pos, и на их место вставляются новые символы.

`S.replace(pos, count, n, c)` - вставить n одинаковых символов, равных с. n имеет целочисленный тип, c - char.

`S.replace(pos, count, T)` - вставить содержимое строки T. T может быть объектом класса string или C-строкой.

`S.replace(pos, count, T, pos2, count2)` - вставить символы строки T начиная с символа с индексом pos количеством count.

### find
Ищет в данной строке первое вхождение другой строки str. Возвращается номер первого символа, начиная с которого далее идет подстрока, равная строке str. Если эта строка не найдена, то возвращается константа string::npos (которая равна -1, но при этом является беззнаковой, то есть на самом деле является большим безннаковым положительным числом).

Если задано значение pos, то поиск начинается с позиции pos, то есть возращаемое значение будет не меньше, чем pos. Если значение pos не указано, то считается, что оно равно 0 - поиск осуществляется с начала строки.

`S.find(str, pos = 0)` - искать первое входение строки str начиная с позиции pos. Если pos не задано - то начиная с начала строки S.

`S.find(str, pos, n)` - искать в данной строке подстроку, равную первым n символам строки str. Значение pos должно быть задано.

### rfind
Ищет последнее вхождение подстроки ("правый" поиск). Способы вызова аналогичны способам вызова метода find.

### find_first_of
Ищет в данной строке первое появление любого из символов данной строки str. Возвращается номер этого символа или значение string::npos.

Если задано значение pos, то поиск начинается с позиции pos, то есть возращаемое значение будет не меньше, чем pos. Если значение pos не указано, то считается, что оно равно 0 - поиск осуществляется с начала строки.

`S.find_first_of(str, pos = 0)` - искать первое входение любого символа строки str начиная с позиции pos. Если pos не задано - то начиная с начала строки S.

### find_last_of
Ищет в данной строке последнее появление любого из символов данной строки str. Способы вызова и возвращаемое значение аналогичны методу find_first_of.

### find_first_not_of
Ищет в данной строке первое появление символа, отличного от символов строки str. Способы вызова и возвращаемое значение аналогичны методу `find_first_of`.

### find_last_not_of
Ищет в данной строке последнее появление символа, отличного от символов строки str. Способы вызова и возвращаемое значение аналогичны методу `find_first_of`.

### c_str
Возвращает указать на область памяти, в которой хранятся символы строки, возвращает значение типа char*. Возвращаемое значение можно рассматривать как C-строку и использовать в функциях, которые должны получать на вход C-строку.

---